<!DOCTYPE html>
<html lang="en" dir="auto">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Farhan al-Maliki — Video Finder</title>

  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Fuse.js for fuzzy search -->
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>

  <!-- Favicon (magnifier) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23000000' d='M10 2a8 8 0 0 1 6.32 12.906l4.387 4.387a1 1 0 0 1-1.414 1.414l-4.387-4.387A8 8 0 1 1 10 2m0 2a6 6 0 1 0 0 12A6 6 0 0 0 10 4'/%3E%3C/svg%3E"/>

  <style>
    .kbd{ padding:.125rem .375rem; border:1px solid #e5e7eb; border-radius:.25rem; font-size:.75rem; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; }
    .result:hover{ transform:translateY(-1px); }
    mark{ background:transparent; box-shadow:inset 0 -0.5em 0 0 rgba(250,204,21,.6); }
  </style>
</head>
<body class="bg-zinc-50 text-zinc-900">
  <div class="max-w-6xl mx-auto p-4 sm:p-8">
    <header class="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between mb-4 sm:mb-6">
      <div>
        <h1 class="text-2xl sm:text-3xl font-semibold tracking-tight">Farhan al-Maliki — Video Finder</h1>
        <p class="text-sm text-zinc-600">Client-side search across episodes and timestamped quotes. Hosted on GitHub Pages.</p>
      </div>
      <div class="text-xs text-zinc-500">Shortcuts: <span class="kbd">/</span> focus • <span class="kbd">Esc</span> clear</div>
    </header>

    <!-- Controls -->
    <div class="grid gap-3 sm:grid-cols-12 items-start">
      <div class="sm:col-span-7">
        <label class="sr-only" for="q">Search</label>
        <input id="q" type="search" placeholder="ابحث هنا … (اكتب كلمة موجودة في الترجمة)" class="w-full rounded-xl border border-zinc-300 bg-white px-4 py-2.5 shadow-sm focus:outline-none focus:ring-2 focus:ring-amber-400" />
        <p class="text-xs text-zinc-500 mt-1">
          Tips: <code>"عبارة تامة"</code> • <code>+مطلوب</code> • <code>-مستبعد</code> • <code>topic:سقيفة</code> • <code>title:المالكي</code>
        </p>
      </div>
      <div class="sm:col-span-3">
        <select id="topic" class="w-full rounded-xl border border-zinc-300 bg-white px-3 py-2.5 shadow-sm focus:outline-none focus:ring-2 focus:ring-amber-400">
          <option value="">All topics</option>
        </select>
      </div>
      <div class="sm:col-span-2 flex gap-2">
        <button id="clearBtn" class="flex-1 rounded-xl border border-zinc-300 px-3 py-2.5 bg-white shadow-sm hover:bg-zinc-50">Clear</button>
        <button id="exportBtn" title="Export results to CSV" class="rounded-xl border border-zinc-300 px-3 py-2.5 bg-white shadow-sm hover:bg-zinc-50">CSV</button>
      </div>
    </div>

    <!-- Stats -->
    <div id="stats" class="text-sm text-zinc-600 my-3"></div>

    <!-- Results -->
    <div id="results" class="grid gap-3"></div>

    <footer class="mt-10 text-xs text-zinc-500">
      <p>Data source: <code>data/index.json</code>. Built with Fuse.js. Inspired by ippsec.rocks.</p>
    </footer>
  </div>

  <script>
    // ===== Config =====
    const DATA_URL = 'data/index.json';

    // Fallback if DATA_URL missing (keep empty)
    const demoData = [];

    // ===== State =====
    let videos = [];
    let fuse;
    let flatRows = [];
    let lastResults = [];
    const titleCache = new Map(); // id -> resolved title

    // ===== Helpers =====
    const $ = (sel) => document.querySelector(sel);
    const resultsEl = $("#results");

    function fmtTime(sec){
      sec = Math.max(0, Math.floor(+sec || 0));
      const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = sec%60;
      return (h? h+":" : "") + String(m).padStart(2,'0') + ":" + String(s).padStart(2,'0');
    }

    function ytAt(url, t){
      try{
        const u = new URL(url);
        if(u.hostname.includes('youtube.com') || u.hostname.includes('youtu.be')){
          u.searchParams.set('t', Math.floor(t));
          return u.toString();
        }
      }catch(e){}
      return url + (url.includes('#')? '&' : '#') + 't=' + Math.floor(t);
    }

    function highlight(text, query){
      if(!query) return text;
      const esc = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const re = new RegExp('(' + esc + ')', 'ig');
      return String(text).replace(re, '<mark>$1</mark>');
    }

    // Normalize Arabic text (remove tashkīl, normalize alif/ya/ta marbuta, etc.)
    function normalizeArabic(s){
      if(!s) return '';
      return s.toLowerCase()
        .replace(/[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06ED]/g,'') // diacritics
        .replace(/[أإآ]/g,'ا')
        .replace(/ى/g,'ي')
        .replace(/ة/g,'ه')
        .replace(/[ؤئ]/g,'ء')
        .replace(/ـ/g,'') // tatweel
        .replace(/[^\p{L}\p{N}\s]/gu,' ')
        .replace(/\s+/g,' ')
        .trim();
    }

    // Parse query tokens: "phrase", +must, -not, topic:, title:
    function parseQuery(q){
      const tokens = (q.match(/"[^"]+"|\S+/g) || []);
      const out = { phrases:[], must:[], mustNot:[], topic:null, title:null, raw:q };
      for(const t of tokens){
        if(t.startsWith('topic:')) out.topic = normalizeArabic(t.slice(6));
        else if(t.startsWith('title:')) out.title = normalizeArabic(t.slice(6));
        else if(t.startsWith('+')) out.must.push(normalizeArabic(t.slice(1)));
        else if(t.startsWith('-')) out.mustNot.push(normalizeArabic(t.slice(1)));
        else if(t.startsWith('"') && t.endsWith('"')) out.phrases.push(normalizeArabic(t.slice(1,-1)));
        else out.must.push(normalizeArabic(t));
      }
      return out;
    }

    // Advanced row matching (after fuzzy prefilter)
    function matchesAdvanced(row, parsed){
      // topic: filter in query
      const topicOK = !parsed.topic ||
        normalizeArabic(row.topic) === parsed.topic ||
        (row.tags||[]).map(normalizeArabic).includes(parsed.topic);
      if(!topicOK) return false;

      // title: filter
      if(parsed.title && !row.titleNorm.includes(parsed.title)) return false;

      // require all MUST words
      for(const w of parsed.must){ if(w && !row.searchBlob.includes(w)) return false; }

      // require each phrase exactly in transcript text
      for(const ph of parsed.phrases){ if(ph && !row.textNorm.includes(ph)) return false; }

      // exclude (-word)
      for(const x of parsed.mustNot){ if(x && row.searchBlob.includes(x)) return false; }

      return true;
    }

    function updateStats(count){
      const q = $('#q').value.trim();
      if (!q) { $('#stats').textContent = ''; return; }
      const topic = $('#topic').value;
      const parts = [];
      parts.push(`${count} result${count===1?'':'s'}`);
      if(q) parts.push(`for “${q}”`);
      if(topic) parts.push(`in topic “${topic}”`);
      $('#stats').textContent = parts.join(' ');
    }

    function downloadCSV(rows){
      const headers = ['episode_id','title','series','date','topic','term','timestamp','quote','url'];
      const escape = (v) => '"' + String(v ?? '').replace(/"/g,'""') + '"';
      const csv = [headers.join(',')].concat(rows.map(r => [r.id, r.title, r.series, r.date, r.topic, r.term, fmtTime(r.t), r.text, ytAt(r.url, r.t)].map(escape).join(','))).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'results.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // Resolve real YouTube title (oEmbed) if JSON title is missing
    async function resolveTitle(id, url){
      if (titleCache.has(id)) return titleCache.get(id);
      try{
        const r = await fetch('https://www.youtube.com/oembed?format=json&url=' + encodeURIComponent(url));
        if (r.ok){
          const data = await r.json();
          const t = data?.title || '';
          if (t) {
            titleCache.set(id, t);
            document.querySelectorAll(`[data-vid="${id}"]`).forEach(el => el.textContent = t);
            return t;
          }
        }
      }catch(_){}
      return '';
    }

    // ===== Build UI / Data =====
    function rebuildUI(){
      // Topics dropdown
      const topics = new Set();
      videos.forEach(v => (v.topics||[]).forEach(t => topics.add(t)));
      const topicSel = $('#topic');
      const current = topicSel.value;
      topicSel.innerHTML = '<option value="">All topics</option>' + Array.from(topics).sort().map(t => `<option>${t}</option>`).join('');
      if(Array.from(topics).includes(current)) topicSel.value = current;

      // Flatten rows & create normalized fields
      flatRows = [];
      for(const v of videos){
        const title = (v.title || v.id || '').trim();
        const titleNorm = normalizeArabic(title);
        const topic0 = (v.topics||[])[0] || '';
        for(const trm of (v.terms||[])){
          const text = trm.text || '';
          const term = trm.term || '';
          const row = {
            id: v.id,
            title,
            titleNorm,
            series: v.series || '',
            date: v.date || '',
            url: v.url,
            lang: v.lang || '',
            topic: topic0,
            term,
            t: trm.t,
            text,
            tags: trm.tags || []
          };
          row.textNorm  = normalizeArabic(text);
          row.termNorm  = normalizeArabic(term);
          row.topicNorm = normalizeArabic(topic0);
          row.searchBlob = [row.textNorm, row.termNorm, row.titleNorm].join(' ');
          flatRows.push(row);
        }
      }

      // Fuse index over normalized fields
      fuse = new Fuse(flatRows, {
        includeMatches: false,
        threshold: 0.35,
        ignoreLocation: true,
        keys: [
          {name:'textNorm',  weight: 0.7},
          {name:'termNorm',  weight: 0.4},
          {name:'titleNorm', weight: 0.2}
        ]
      });

      // Initial state: show nothing until a query exists
      resultsEl.innerHTML = '';
      $('#stats').textContent = '';

      // If URL already has a query, run it
      const params = new URLSearchParams(location.hash.slice(1));
      $('#q').value = params.get('q') || '';
      $('#topic').value = params.get('topic') || '';
      if ($('#q').value.trim()) runSearch();
    }

    function runSearch(){
      const qRaw = $('#q').value.trim();
      const parsed = parseQuery(qRaw);

      // sync URL hash
      const p = new URLSearchParams();
      if(qRaw) p.set('q', qRaw);
      if(parsed.topic) p.set('topic', parsed.topic);
      history.replaceState(null, '', '#' + p.toString());

      // show nothing until user types
      if (!qRaw){
        lastResults = [];
        resultsEl.innerHTML = '';
        $('#stats').textContent = '';
        return;
      }

      // UI topic dropdown filter first
      const topicSel = $('#topic').value;
      let rows = flatRows;
      if(topicSel) rows = rows.filter(r => r.topic === topicSel || (r.tags||[]).includes(topicSel));

      // fuzzy prefilter using MUST words; if none, start from all rows
      const mustQ = parsed.must.join(' ').trim();
      let results = mustQ ? fuse.search(mustQ).map(r => r.item) : rows.slice();

      // apply advanced filters (phrases, -not, title:, topic:)
      results = results.filter(r => matchesAdvanced(r, parsed));

      lastResults = results;
      renderResultsGrouped(results, qRaw);
    }

    async function renderResultsGrouped(rows, q){
      const grouped = new Map();
      for(const r of rows){
        if(!grouped.has(r.id)) grouped.set(r.id, []);
        grouped.get(r.id).push(r);
      }

      const cards = [];
      const toResolve = [];

      for (const [id, items] of grouped){
        items.sort((a,b)=>a.t-b.t);
        const v = items[0];

        const knownTitle = (v.title || '').trim();
        const showTitle = knownTitle || titleCache.get(id) || id;
        if (!knownTitle && !titleCache.has(id)) toResolve.push({id, url: v.url});

        const date  = v.date || '';
        const series= v.series || '';
        const topic = v.topic || '';
        const count = items.length;

        const listFirst = items.slice(0, 10).map(it => {
          const jump = ytAt(it.url, it.t);
          const text = highlight(it.text || it.term || '', q);
          return `<li class="flex items-start gap-2">
                    <a class="shrink-0 rounded-lg bg-zinc-100 px-2 py-0.5 text-sm" href="${jump}" target="_blank" rel="noopener">${fmtTime(it.t)}</a>
                    <span class="text-sm text-zinc-700">${text}</span>
                  </li>`;
        }).join('');

        const extra = items.length - 10;
        const listRest = extra > 0 ? `
          <details class="mt-2">
            <summary class="cursor-pointer text-sm text-amber-700 hover:underline">Show ${extra} more timestamps</summary>
            <ul class="mt-2 grid gap-2">
              ${items.slice(10).map(it => {
                const jump = ytAt(it.url, it.t);
                return `<li class="flex items-start gap-2">
                          <a class="shrink-0 rounded-lg bg-zinc-100 px-2 py-0.5 text-sm" href="${jump}" target="_blank" rel="noopener">${fmtTime(it.t)}</a>
                          <span class="text-sm text-zinc-700">${highlight(it.text||it.term||'', q)}</span>
                        </li>`;
              }).join('')}
            </ul>
          </details>` : '';

        cards.push(`
          <div class="result block rounded-xl border border-zinc-200 bg-white p-4 shadow-sm hover:shadow-md">
            <div class="flex items-center justify-between gap-3">
              <div class="font-medium" data-vid="${id}">${showTitle}</div>
              <div class="text-xs text-zinc-500">${series} ${series && date ? '•' : ''} ${date}</div>
            </div>
            <div class="mt-1 flex flex-wrap items-center gap-2 text-sm">
              ${topic ? `<span class="rounded-lg bg-zinc-100 px-2 py-0.5">${topic}</span>` : ''}
              <span class="rounded-lg bg-amber-100 px-2 py-0.5">${count} hit${count===1?'':'s'}</span>
            </div>
            <ul class="mt-3 grid gap-2">${listFirst}</ul>
            ${listRest}
          </div>
        `);
      }

      updateStats(rows.length);
      resultsEl.innerHTML = cards.join('') || `<div class="text-sm text-zinc-500">No matches. Try a different word (in the same language as the transcript).</div>`;

      // resolve missing titles in background
      for (const g of toResolve){ resolveTitle(g.id, g.url); }
    }

    // ===== Events =====
    document.addEventListener('keydown', (e) => {
      if(e.key === '/' && document.activeElement !== $('#q')){ e.preventDefault(); $('#q').focus(); $('#q').select(); }
      if(e.key === 'Escape'){ $('#q').value=''; runSearch(); }
    });
    $('#q').addEventListener('input', runSearch);
    $('#topic').addEventListener('change', runSearch);
    $('#clearBtn').addEventListener('click', () => { $('#q').value=''; $('#topic').value=''; runSearch(); $('#q').focus(); });
    $('#exportBtn').addEventListener('click', () => downloadCSV(lastResults));

    // ===== Data load =====
    async function maybeLoadExternal(){
      try{
        const r = await fetch(DATA_URL, { cache: 'no-store' });
        if (r.ok) {
          const data = await r.json();
          if (Array.isArray(data)) return data;
        }
      }catch(_){}
      return demoData;
    }

    (async function init(){
      videos = await maybeLoadExternal();
      // cache any titles provided by JSON
      videos.forEach(v => { if ((v.title||'').trim()) titleCache.set(v.id, v.title.trim()); });
      rebuildUI();
    })();
  </script>
</body>
</html>
